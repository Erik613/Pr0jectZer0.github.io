# Vorlesung 12: MV* Architekturmuster 

## Einleitung

### Entwurfsmuster vs. Architekturmuster

#### Entwurfsmuster
* Richtlinien, wie man gängige Probleme bei der Implementierung eines Softwaresystems löst

#### Architekturmuster
* Richtlinien, um Struktur und Verhalten von Softwaresystemen abstrakt zu modellieren
* Richtlinien, wie die Interaktion zwischen zwischen Teilen des Softwaresystems (Pakete, Subsystemen, Server, Clients, Datenbanken) stattfinden soll

### Interaktive Softwaresysteme mit GUI
* Typisch für graphische Benutzungsschnittstellen ist
    - dass es Objekte zur Eingabe gibt,
    - die zur Veränderung der eigentlichen Datenklasse führen,
    - die dann wiederum eventuell zu Änderung der Anzeige führen <br/><img src="images/VL12/gui.png" width="400">
* Beispiel für „ungute“ Softwarestruktur bzw. Aufteilung der Programmlogik:
GUI enthält Button. Event-Listener für Button wird in der GUI-Klasse implementiert
(Callback). Dort wird dann Geschäftslogik implementiert. Geschäftslogik ist
dann nicht benutzbar für andere Teile des Softwaresystems und nicht testbar

### MV*-Architekturmuster
* Lösungen für das genannte Problem führen zu Model-View-* Ansätzen
* Architekturmuster für interaktive Anwendungen mit GUI
* MV*-Vorteile
    - Single Responsibilty Principle: Separiert Logik, Präsentation und Daten
    - Separation of concerns (insbesondere gut für große Softwaresysteme mit vielen Software-Entwicklern)
    - Wartbarkeit, Erweiterbarkeit, Austauschbarkeit, Testbarkeit
    - Unterschiedliche Visualisierungen der Daten (Text, Grafik, etc.)
<img src="images/VL12/muster.png" width="500">


## Model View Controller
* Model enthält Geschäftslogik und Zustandsinformation der Softwareanwendung
* View stellt die Daten des Models dar, ist also „abhängig“ vom Model.
Die View ist Beobachter des Zustands, um den aktuellen Zustand darzustellen;
es kann viele Views für ein Model geben. HTML, JSF, Swing, JavaFX <br /><img src="images/VL12/mvcbeispiel.png" width="350">
* Controller. Zwischenschicht, die die Eingaben aus der View verarbeitet
und zwischen View und einem oder mehreren Models vermittelt.
Ein Controller legt das Verhalten der Software auf Benutzereingaben
fest und kann für unterschiedliche Views benutzt werden. Wichtig:
Im Controller steckt keine Geschäftslogik

#### View
* (Graphische) Präsentation (Style, Layout) der Daten
* Interaktion mit dem Nutzer. Nutzeraktionen werden an Controller weitergegeben
* Statusänderung der View über Abfrage am Model
* Implementierung von Logik in der View (=GUI-Logik)
    - Animation, Formatierung, Validierung, Aus/Einblenden von Feldern in Abhängigkeit des Zustands
* Fehler bei der Implementierung von Logik
    - Implementierung von Geschäftslogik in der View
    - Aufrufe von Speicherfunktionen des Models

#### Model
* Enthält Daten und Geschäftslogik
* Kennt nicht die konkreten Views (lose Kopplung)
* Jede Änderung der Daten verursacht Aktualisierung der Views

#### Controller
* Verbindet als Zwischenschicht das View und Model. Enthält Steuerungslogik. Enthält keine Geschäftslogik.
* Reagiert auf Nutzereingaben (Tastatureingaben, Mausklicks, etc)
* Ruft Geschäftslogik vom Model (Delegation) auf und selektiert Views
* Ein Controller kann für verschiedene Views verwendet werden

### Active und Passive MVC
* Unterschied in der Synchronisierung der Daten im Model und View
* Passive Model
    - Nur der Controller manipuliert das Model und informiert die View,
    dass sich das Model geändert hat und dass sie sich „updaten“ soll.
    Die View holt dann Daten vom Model
* Active Model
    - Das Model hat Beobachter, nämlich die View(s).
    Wenn sich das Model ändert, informiert das Model die Beobachter,
    sich auf den neuesten Model-Stand zu bringen
    - Sinnvoll, wenn Model nicht nur durch den Controller verändert wird
    - Form des Observer-Entwurfsmusters

#### Active MVC
* In der View tritt ein Ereignis auf. Der Controller wird informiert.
* Controller steuert Änderungen des Modells
* Model teilt allen Views mit, dass eine Änderung aufgetreten ist
* Views stellen den aktuellen Zustand dar

<img src="images/VL12/activemodel1.png" width="300"><img src="images/VL12/activemodel2.png" width="300">

#### Passive MVC
<center><img src="images/VL12/passivemodel.png" width="500"></center>

### Web MVC (Model2 Architektur)
* MVC wurde Desktop-Anwendungen entwickelt,
  bei dem die Software auf einem Computer in einem Prozess läuft
* Als das WWW aufkam, wurde MVC für Webanwendungen genutzt
  HTTP ist zustandslos. Notwendigkeit von Sessions zwischen Client und Server
* MVC in verteilten Systemen: „VCM-Architektur“, Controller enthält Steuerungslogik

<center><img src="images/VL12/wmvc1.png" width="500"></center><br />
<center><img src="images/VL12/wmvc2.png" width="500"></center>

### RIA MVC (Rich Client Internet Application)
* Die Geschäfts- und Steuerungslogik wird auf dem Client ausgeführt
* Das Client-Model synchronisiert sich mit dem Model, das auf dem Server gespeichert wird

<center><img src="images/VL12/rmvc.png" width="500"></center>

## MVP

## MVVM

### Zusammenfassung

- **Model:** Business Objekte und Geschäftslogik

- **View:** Grafische Schnittstelle zum Benutzer

- **Presenter:**

  - 1-zu-1 Beziehung zwischen View und Presenter
  - Jede View implementiert ein Interface, durch das der Presenter mit der View interagieren kann
  - Jede View hat eine Referenz zumPresenter und kann dort Steuerungslogik initiieren

- **ViewModel:**

  - n-zu-1 Beziehung zwischen View und ViewModel
  - Views interagiert mit ViewModel durch Bindung an Attribute und Funktionen

- **Controller:**

  - n-zu-1 Beziehung zwischen View und Controller
  - Passive Model: Kommunikation View <->Model über Controller
  - Active-Model: Updates durch Observer-Pattern behandelt

  ​

<center><img src="images\VL12\Zusammenfassung.png" width=500></center>

| MVC                                      | MVP                                      | MVVM                                     |
| ---------------------------------------- | ---------------------------------------- | ---------------------------------------- |
| View sendet Eingabeereignisse an den Controller über „Callback-Handler“ | View interagiert mit dem Presenter durch Aufruf von Presenter-Funktionen | View bindet sich direkt an das ViewModel |
| View erhält in der „Active Model“-Variante Zustandsänderungen direkt vom Model ohne Aktivität des Controllers | Presenter interagiert mit der View durch Aufrufvon Interface-Funktionen, die durch die View implementiert sind | Änderungen in der View werden direkt in das ViewModel geschrieben und umgekehrt |
| Active Model zu benutzen, wenn das Model von unterschiedlichen Prozessen verändert wird | Zu benutzen, wenn ein Databinding nicht möglich ist | Zu benutzen, wenn Databinding möglich    |

