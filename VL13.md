# Vorlesung 13: Entwurfsmuster

## Einleitung

## Composite

## Observer

### Observer - Observable (Beobachter)
- Auch "Publish-Subscribe oder "(Event-)Listener"
- Objekte zueinander konsistent halten, ohne diese eng miteinander zu koppeln
- Subjekte bieten die Möglichkeit, dass sich Interessenten anmelden (z. B. Kanal abonnieren)
- Bei jeder Subjektzustandsänderung werden diese Interessenten informiert (z. B. neue Nachrichten)
- Observable (= Subjekt)
	- register oder addListener (Observer registrieren)
	- unregister oder removeListener (registrierte Observer entfernen)
	- noftiy, notifyAll (update-Methoden aller registrierten Observer aufrufen)
	- setState (zustandsändernde Operation(en) für beliebige Clients)
	- getSate (Abfrage des aktuellen Zustands)
- Observer (= Interessent)
	- update (Reaktion auf Zuständsänderung des Subjekts)
<img src="images\VL13\Observer_Observable.png" width=100%>
<img src="images\VL13\Observer_Sequenzdiagramm.png" width=100%>

### GoF-Pattern Übersicht
<img src="images\VL13\Observer_GoF-Pattern.png" width=100%>

## Command
Bei einer Textverarbeitung können viele Funktionen von unterschiedlichen Stellen aus aufgerufen werden, z.B. Menü, Button, Popup-Menü bei Rechtsklick, Tastaturkürzel

* Die Funktion soll nicht immer neu implementiert werden
* Die Funktion soll rückgängig gemacht werden können
* Die Funktion soll mehrfach ausgeführt werden

Wie kann das softwaretechnisch realisiert werden, wenn die Funktionen eng mit den aufrufenden Objekten verbunden sind?

**Lösung:**
* Den Befehl in einer Klasse kapseln
* Der selbe Befehl kann von mehreren Stellen aus aufgerufen werden
* Die Befehsobjekte können in einer Befehlsgeschichte gespeichert werden
* Operation als Objekte mit Methode **execute()** darstellen
* Rückgängig mit Methode **undo()**

### UML-Diagramm
<center><img src="images\VL13\commanduml.png" width=75%></center>

### Beispielprogramm
<center><img src="images\VL13\commandbsp.png" width=75%></center>

### Verbindung von Observer und Command in java
* Observer
	* Buttons, Menü-Einträge und Tasten generieren "ActionEvents"
	* Interface "ActionListener" ist vordefiniert
* Das "ActionListener„-Interface  implementieren und dann Instanzen davon bei Buttons, MenuItems, etc. registrieren

#### Elegante Verbindung von Observer und Command
* Commands sind **ActionListener** von Buttons, Menüs, etc.
* Einheitlicher Aufruf via **actionPerformed(ActionEvent evt)**
* Buttons und Menüs sind **PropertyChangeListener** von Commands
* Aktivierung / Deaktivierung

#### Wiederverwendung
* Gleiche **Action** für Menu, Button, Key

### Oberserver und Command in Java
<center><img src="images\VL13\commandjava.png" width=75%></center>
<center><img src="images\VL13\commandjava2.png" width=75%></center>

### GoF Pattern Übersicht
<center><img src="images\VL13\commandgof.png" width=75%></center>

## Adapter

### Zweck

- Adapter (Synonym: Wrapper) passt die Schnittstelle einer Klasse an eine andere Schnittstelle an, die von ihren Klienten erwartet wird
- lässt Klassen zusammenarbeiten, die wegen inkompatibler Schnittstellen ansonsten dazu nicht in der Lage wären

<center><img src="images\VL13\Adapter_Zweck.png" width=500></center>

### Adapter

- „Adapter“ erbt von und verhält sich wie „Ziel“ und benutzt die „Adaptierte Klasse“
- Adapter leitet Aufruf der gewünschten Funktionalität an die adaptierte Klasse weiter

<center><img src="images\VL13\Adapter.png" width=500></center>

### Objekt-Adapter

<center><img src="images\VL13\Adapter_Objekt_1.png" width=500></center>

<center><img src="images\VL13\Adapter_Objekt_2.png" width=500></center>

### Klassen-Adapter

<center><img src="images\VL13\Adapter_Klassen.png" width=500></center>

<center><img src="images\VL13\Adapter_Klassen_Mehrfachvererbung.png" width=500></center>

## Bridge

## Factory Method

## Abstract Factory

## Proxy
* Proxy als Stellvertreter zu einem anderen Ding
* Client kommuniziert nur über eine Schnittstelle mit dem Proxy bzw. realen Subjekt
* Der Zugriff auf die „wertvolle“ Ressource wird durch eine vorgeschaltete Klasse gesteuert
* Der Nutzer des Proxys nutzen diesen wie die eigentliche Klasse

<center><img src="images\VL13\proxy1.png" width="400"></center>

### Typische Beispiele: Remote Proxy
* Ein Objekt liegt auf einem anderen Rechner.
Das RemoteProxy ist die Schnittstelle zum entfernt liegenden Objekt
* Ein Remote-Proxy ist ein lokaler Stellvertreter für ein Objekt in
einem anderen Adressraum. Er wird beispielsweise in Netzwerkanwendungen verwendet

<center><img src="images\VL13\proxy2.png" width="400"></center>

### Andere Proxy-Beispiele
* Ein virtueller Proxy dient der Verzögerung „teurer“ Operationen auf den
Zeitpunkt des tatsächlichen Bedarfs
* Ein Schutzproxy setzt Zugriffsrechte auf ein Objekt durch

<center><img src="images\VL13\proxy3.png" width="400"></center>

### Proxy-Impementierungsmöglichkeiten

```java
public interface KlasseMitWertvollemInhalt {
	public int anfrage(String details);
}
```
```java
public class RealeKlasse implements KlasseMitWertvollemInhalt {

	private Verbindung verbindung;

	public RealeKlasse(String verbindungsdaten){
		verbindung = new Verbindung(verbindungsdaten);
	}

	public int anfrage(String details){
		return verbindung.befragen(details);
	}
}
```
```java
public class Proxy implements KlasseMitWertvollemInhalt {

    private static RealeKlasse realesObjekt;

	public Proxy() {
		if (realesObjekt == null)
            realesObjekt = new RealeKlasse("Spezialinfos");
	}

	public int anfrage(String details) {
		return realesObjekt.anfrage(details);
	}
}
```
```java
public class Nutzer {

	public int proxyNutzen(String anfrage) {
		KlasseMitWertvollemInhalt k = new Proxy();
		return k.anfrage(anfrage);
	}

	public static void main(String[] s) {
		Nutzer n = new Nutzer();
		System.out.println(n.proxyNutzen("gib41"));
	}
}
```


### Unterschied zwischen Proxy vs. Adapter vs. Facade vs. Bridge
#### Proxy
* hat dieselbe Schnittstelle wir das „reale Subjekt“
* macht einen Zugriff auf eine Implementation über die gleiche Abstraktion mittelbar
über ein anderes Objekt (z.B. wegen Remote, Cache, Logging, Locking, Zugriffsrecht, etc.)

#### Adapter
* Ein Adapter kann eine andere Schnittstelle besitzen
* passt eine vorgegebene Implementation an eine nicht kompatible Abstraktion an
* wird benutzt, nachdem die Software von unterschiedlichen Parteien nacheinander implementiert wurde
* dient dazu, voneinander unabhängigen Code “zusammen zu schweißen”
* “Fix” für das Problem, wenn externe Bibliotheken zu einem Softwaresystem hinzugefügt werden

#### Facade
* fasst mehrere Schnittstellen zu einer Schnittstelle zusammen

#### Bridge
* trennt Implementation von Abstraktion (=Interface), um beide unabhängig
voneinander variieren zu können
* wird bereits vor der Implementierung “angedacht” und benutzt, so dass die Abstraktion
und Implementierung unabhängig voneinander entwickelt und die Implementierung ausgetauscht werden kann

### GoF-Pattern Übersicht
<center><img src="images\VL13\proxyübersicht.png" width="400"></center>


## State

## Singleton

## Facade

## Builder

## Template Method

## Visitor

## Architekturmuster vs. Entwurfsmuster

## Fazit
